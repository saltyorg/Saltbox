#########################################################################
# Title:         Saltbox: Restore Role                                  #
# Author(s):     l3uddz, desimaniac                                     #
# URL:           https://github.com/saltyorg/Saltbox                    #
# --                                                                    #
#########################################################################
#                   GNU General Public License v3.0                     #
#########################################################################
---
- name: Fail when rclone backup method is disabled and using restore_tar
  ansible.builtin.fail:
    msg:
      - "Rclone backup is not enabled."
      - "You must enable rclone, in the backup settings, to perform a with a specific tar file restore."
  when: (not backup_rclone_enabled) and (restore_tar is defined)

- name: Fail when local backup method is enabled and using restore_tar
  ansible.builtin.fail:
    msg:
      - "The restore_tar setting does not work with a local backup enabled."
      - "Remember to empty the local backup folder if you disable the setting."
  when: backup_rclone_enabled and (restore_tar is defined)

- name: "Check if user '{{ user.name }}' exists"
  ansible.builtin.shell: "id -un {{ user.name }} >/dev/null 2>&1;"
  register: user_check
  failed_when: (user_check.rc > 1)

- name: User Role
  ansible.builtin.include_role:
    name: user
  when: (user_check.rc == 1) and (not restore_tar is defined)

- name: Set shell
  ansible.builtin.include_role:
    name: shell
  when: (user_check.rc == 1) and (not restore_tar is defined)

- name: Variables
  ansible.builtin.include_tasks: "variables.yml"

- name: "Check if 'localhost.yml' exists in '{{ playbook_dir }}'"
  ansible.builtin.stat:
    path: "{{ playbook_dir }}/localhost.yml"
  register: localhost_yml_playbook_dir

- name: "Import 'localhost.yml' from '{{ playbook_dir }}'"
  when: localhost_yml_playbook_dir.stat.exists and (not restore_tar is defined)
  block:
    - name: "Check if a previous 'localhost.yml' exists"
      ansible.builtin.stat:
        path: "/srv/git/saltbox/inventories/host_vars/localhost.yml"
      register: localhost_yml_default_path

    - name: "Backup previous 'localhost.yml' (if it exists)"
      ansible.builtin.copy:
        src: "/srv/git/saltbox/inventories/host_vars/localhost.yml"
        dest: "/srv/git/saltbox/inventories/host_vars/localhost.yml.bak"
        owner: "{{ user.name }}"
        group: "{{ user.name }}"
        mode: "0664"
        force: true
      when: localhost_yml_default_path.stat.exists

    - name: "Remove previous 'localhost.yml' (if it exists)"
      ansible.builtin.file:
        path: "/srv/git/saltbox/inventories/host_vars/localhost.yml"
        state: absent
      when: localhost_yml_default_path.stat.exists

    - name: "Import 'localhost.yml' from '{{ playbook_dir }}'"
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/localhost.yml"
        dest: "/srv/git/saltbox/inventories/host_vars/localhost.yml"
        owner: "{{ user.name }}"
        group: "{{ user.name }}"
        mode: "0664"
        force: true

    - name: "Remove imported 'localhost.yml' from '{{ playbook_dir }}'"
      ansible.builtin.file:
        path: "{{ playbook_dir }}/localhost.yml"
        state: absent

- name: BTRFS Tasks
  ansible.builtin.include_tasks: "btrfs.yml"
  loop:
    - "{{ server_appdata_path }}"
    - "{{ server_local_folder_path }}"
  loop_control:
    loop_var: outer_item

- name: Create common directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: "0775"
  with_items:
    - "{{ server_appdata_path }}"
    - "{{ server_local_folder_path }}"

- name: "Create backup location '{{ backup.local.destination }}'"
  ansible.builtin.file:
    path: "{{ backup.local.destination }}"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: "0775"
    recurse: true

- name: "Create backup location '{{ backup.local.destination }}/opt'"
  ansible.builtin.file:
    path: "{{ backup.local.destination }}/opt"
    state: directory
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: "0775"
    recurse: true

- name: Check if previous backup exists locally
  ansible.builtin.find:
    paths:
      - "{{ backup.local.destination }}/opt"
    file_type: file
    patterns: '*.tar'
  register: dir_files

# Restore from remote backup when local backup does not exist
- name: Restore Remote
  ansible.builtin.include_tasks: "restore_remote.yml"
  when: (dir_files.matched | int == 0) and (not restore_tar is defined)

- name: Restore specific tar
  ansible.builtin.include_tasks: "restore_tar.yml"
  when: (dir_files.matched | int == 0) and (restore_tar is defined)

- name: "Look for 'backup_excludes_list.txt' file in '{{ backup.local.destination }}'"
  ansible.builtin.stat:
    path: "{{ backup.local.destination }}/backup_excludes_list.txt"
  register: backup_excludes_list

- name: "Delete 'z' opt folder when doing full restore"
  ansible.builtin.file:
    path: "{{ server_appdata_path }}/z"
    state: absent
  when: (not restore_tar is defined)

- name: "Copy 'backup_excludes_list.txt' from '{{ backup.local.destination }}'."
  ansible.builtin.copy:
    src: "{{ backup.local.destination }}/backup_excludes_list.txt"
    dest: "{{ playbook_dir }}"
    owner: "{{ user.name }}"
    group: "{{ user.name }}"
    mode: "0664"
    force: true
  when: backup_excludes_list.stat.exists and (not restore_tar is defined)

- name: "Check for existing backup folders (full restore)"
  ansible.builtin.stat:
    path: "{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}_bak"
  with_fileglob:
    - "{{ backup.local.destination }}/opt/*.tar"
  register: existing_bak_folders_full
  when: (not restore_tar is defined)

- name: "Fail if backup folders already exist (full restore)"
  ansible.builtin.fail:
    msg:
      - "Backup folder '{{ server_appdata_path }}/{{ (item.item | basename | splitext)[0] }}_bak' already exists."
      - "Please remove or rename existing backup folders before running restore."
      - "This prevents accidental loss of existing backup data."
  with_items: "{{ existing_bak_folders_full.results }}"
  when: (not restore_tar is defined) and item.stat.exists
  loop_control:
    label: "'{{ server_appdata_path }}/{{ (item.item | basename | splitext)[0] }}_bak'"

- name: "Backup existing folders in '{{ server_appdata_path }}' to prevent overwriting them (full restore)"
  ansible.builtin.shell: mv '{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}' '{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}_bak' 2>/dev/null || true
  with_fileglob:
    - "{{ backup.local.destination }}/opt/*.tar"
  loop_control:
    label: "'{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}' --> '{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}_bak'"
  when: (not restore_tar is defined)

- name: "Check for existing backup folder (specific tar restore)"
  ansible.builtin.stat:
    path: "{{ server_appdata_path }}/{{ (restore_tar | basename | splitext)[0] }}_bak"
  register: existing_bak_folder_specific
  when: (restore_tar is defined)

- name: "Fail if backup folder already exists (specific tar restore)"
  ansible.builtin.fail:
    msg:
      - "Backup folder '{{ server_appdata_path }}/{{ (restore_tar | basename | splitext)[0] }}_bak' already exists."
      - "Please remove or rename the existing backup folder before running restore."
      - "This prevents accidental loss of existing backup data."
  when: (restore_tar is defined) and existing_bak_folder_specific.stat.exists

- name: "Backup existing folder in '{{ server_appdata_path }}' to prevent overwriting it (specific tar restore)"
  ansible.builtin.shell: mv '{{ server_appdata_path }}/{{ (restore_tar | basename | splitext)[0] }}' '{{ server_appdata_path }}/{{ (restore_tar | basename | splitext)[0] }}_bak' 2>/dev/null || true
  when: (restore_tar is defined)

- name: "Unarchive backup tarballs into '{{ server_appdata_path }}' (full restore)"
  ansible.builtin.shell: tar -xf '{{ item }}' -C '{{ server_appdata_path }}/'
  with_fileglob:
    - "{{ backup.local.destination }}/opt/*.tar"
  loop_control:
    label: "'{{ item | basename }}' --> '{{ server_appdata_path }}/{{ (item | basename | splitext)[0] }}'"
  register: unarchive
  when: (not restore_tar is defined)

- name: "Unarchive specific backup tarball into '{{ server_appdata_path }}' (specific tar restore)"
  ansible.builtin.shell: tar -xf '{{ backup.local.destination }}/opt/{{ restore_tar }}' -C '{{ server_appdata_path }}/'
  register: unarchive
  when: (restore_tar is defined)

- name: "Set '{{ server_appdata_path }}' ownership and permissions"
  ansible.builtin.include_tasks: "permissions.yml"
  tags: opt-permissions-reset

- name: Cleanup backup location
  ansible.builtin.file:
    path: "{{ backup.local.destination }}"
    state: absent
  become: true
  become_user: "{{ user.name }}"
  when: (not backup_local_enabled)

- name: Finished restoring the backup
  ansible.builtin.debug:
    msg: Finished restoring the backup. You are now ready to install Saltbox!
  when: (unarchive is succeeded)

- name: Settings Role
  ansible.builtin.include_role:
    name: settings
